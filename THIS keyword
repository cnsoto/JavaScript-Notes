# INTRODUCCION

JavaScript is a programming language that uses lexical scope with function scope to define the variables values,
except for the **THIS** keyword, which is a variable whos value seems to change strangely and that we cannot control.

The reason to this behavior is that the object **THIS** has some kind of **dynamic scope** to define it's value, 
that's why on execution time **THIS** changes to values that we didn't defined in our code.

The changes to **THIS** values are due to the close relationship between the **THIS** object and the **execution context** in JavaScript: 
"If the execution context changes also the **THIS** value". During the **execution time** of one code line of a JavaScript program, the 
**execution context**(enviroment or scope in which a line of code is being executed) changes taking into consideration the owner object 
of the function being call and **this** stores a reference to this owner object.

It's important to understand how the value of **THIS** changes because sometimes it may seem that has one value but it changes to another, 
for example: a function being call inside an object's method.
----
JS Code

let person = {
  name:"Carlos",
  talk: function(){
    let text= 'Mi name is';
    function innerfunction(){
      console.log(`${text} + ${this.name}`);
    }
    innerfunction();
  }
}
----
As mention before the **execution context** changes at **execution time** due to the function being call by it's owner object
Since a function can be call diferent ways (implicit, explicit, event listenes, others.), the same function can have diferent **execution context**, 
whichs means a function can have diferents values for **THIS** keyword. 

An easy way to know the value of **THIS** is to determine how the function that contains the **THIS** keyword was call at **execution time**. 
It helps to answer the question: Who call the function?

In **execution time** who can call a function to execute can be the Global object (window if we are working on a browser, global object on NodeJS), 
objects (a define structure with methods and properties), DOM elements, primitives data types (string, boolean, number, bigint, undefined, symbol) 
being all posibles values of **THIS**.

In JavaScript is not posible to alter how the **lexical scope** works, but it is possible to control the **execution context** in which we call our functions. 
We can control and fixed the value of **THIS** with: **clousure**, **call**, **apply**, **bind** and **arrow functions**.
----
JS code

function boo(){ return this+13}
function foo(){ return typeof this}
function buzz(){ return this}
function too(){ return `${typeof this} 13`}
var roles = Symbol("rol")
boo.call(1)// 14
boo.call("12")// "1213"
boo.call(true)// 14
boo.call(false)// 13
boo.call(0.3)// 13.3
typeof roles// "symbol"
boo.call(roles)// Uncaught TypeError: Cannot convert a Symbol value to a number
foo.call(roles)// "object"
buzz.call(roles)// Symbol {Symbol(rol)}
too.call(roles)// "object 13"
----
Now that we know the **THIS** object it is important to understand how it is bind to the scope:
 -Default(window)
 -new
 -Lexical
 -implicit
 -explicit
               
# **THIS** Default binding
When a function is invoke as a functions **THIS**'s value refers to the **Global Object** (Window).
----
JS Code

function test(){
  console.log(this === window)
}
console.log(this === window)// true
test()// true
----
When belonging to the **global context** the **THIS** value can be change outside the function, their's no data encapsuling.
----
JS Code

const TellAge = function(){
  console.log(this.age)
}
TellAge()// undefined
window.age = 22
TellAge()// 22
----
For correcting this behavior the strict mode is use. A function which has **'use strict'** in their scope the value **THIS** will be **undefined** instead 
of the **window** object.
----
JS Code

const TellAge2 = function(){
  'use strict'
  console.log(this.age)
}
TellAge2()// undefined
window.age = 22
TellAge2()// Uncaught TypeError: Cannot read property 'age' of undefined at TellAge2
----
# **THIS** new binding
The **NEW** keyword is use together with construction functions assigning it to a variable to create objects. In which **THIS** value is refeer 
to the new created instance.
----
JS Code

const Person = function(fn, ln){
  this.first_name = fn;
  this.last_name = ln;
  this.displayName = function(){
    console.log(`Name: ${this.first_name} ${this.last_name}`)
  }
}
let mom = new Person("Joceline","Aguilar")
let dad = new Person("Noel", "Soto")
mom.displayName()//Name: Joceline Aguilar
dad.displayName()//Name: Noel Soto 
mom===dad// false
----
# **THIS** Lexical Context binding
In regular functions every new function defined has its own **THIS** keyword value. Arrow functions on the other hand don't have their own **THIS** keyword.

# **THIS** Implicit binding           
In this case we see the method invocation pattern. The **THIS** keyword is really useful when use for object and is good practice to set the strict mode
on functions which have it in their context.
----
JS Code

const fn = function() {
  return this;
};

const obj1 = { fn }; //ES6 Feature
const obj2 = { fn }; //ES6 Feature

obj1.fn() === obj1; // true
obj1.fn() === obj2; // false

obj2.fn() === obj1; // false
obj2.fn() === obj2; // true

const foo = function(){
  'use strict'
  console.log(this === window)
}

let user = {
  count: 10,
  foo,
  foo1: function(){
    console.log(this === window)
  }
}

user.foo()// false
const fun1 = user.foo1;
fun1()// true
user.foo1()// false
----

# **THIS** Explicit binding
